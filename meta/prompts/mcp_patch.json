{
  "task": "Harden shutdown lifecycle and test robustness (with grace period)",
  "objective": "Make shutdown deterministic: run loop always cleans up, logs always flush, tests donâ€™t flake on CI.",
  "changes": [
    {
      "id": "remove_self_kill",
      "description": "Stop main() from re-sending SIGTERM to itself. Let the run loop handle cleanup and file removal.",
      "edits": [
        {
          "file": "mcp/__main__.py",
          "pattern": "if code < 0:[\\s\\S]*?sys.exit\\([^)]*\\)",
          "multiple": false,
          "replacement": "if code < 0:\n        signum = -code\n        sys.exit(128 + signum)\n    else:\n        sys.exit(code)"
        }
      ]
    },
    {
      "id": "flush_shutdown_logs",
      "description": "Explicitly flush stderr after each shutdown log event.",
      "edits": [
        {
          "file": "mcp/__main__.py",
          "pattern": "shutdown_logged = True",
          "multiple": true,
          "replacement": "shutdown_logged = True\n            try:\n                sys.stderr.flush()\n            except Exception:\n                pass"
        }
      ]
    },
    {
      "id": "robust_wait_for_line_with_grace",
      "description": "Update _wait_for_line to allow a short grace period after process exit for stderr flush, instead of waiting full timeout.",
      "edits": [
        {
          "file": "tests/conftest.py",
          "pattern": "def _wait_for_line",
          "multiple": false,
          "replacement": "def _wait_for_line(stream, proc, needle: str, timeout: float = 10.0) -> str:\n    import time\n    deadline = time.time() + timeout\n    lines = []\n    grace_period = 1.0  # allow stderr flush after exit\n    exited_at = None\n\n    while time.time() < deadline:\n        line = stream.readline()\n        if not line:\n            if proc.poll() is not None:\n                if exited_at is None:\n                    exited_at = time.time()\n                if time.time() - exited_at > grace_period:\n                    break\n                time.sleep(0.05)\n                continue\n            time.sleep(0.05)\n            continue\n        text = line.strip()\n        lines.append(text)\n        if needle in text:\n            return text\n    raise AssertionError(f\"did not observe '{needle}' in output: {lines}\")"
        }
      ]
    }
  ],
  "constraints": {
    "rules": [
      "No new dependencies.",
      "Only modify the listed files.",
      "One control path handles shutdown (run loop only).",
      "Tests must remain deterministic."
    ]
  },
  "exit_criteria": [
    "Shutdown logs always flushed explicitly.",
    "Ready file always removed by run loop cleanup (not skipped).",
    "_wait_for_line drains stderr for up to 1s after process exit.",
    "All tests pass locally on Python 3.11.",
    "CI stable across all configured Python versions."
  ]
}
