{
  "task": "Close remaining MCP v0.2.7 audit gaps",
  "objective": "Tighten JSON-RPC compliance and extend signal lifecycle test coverage so audit has no Missing/Divergent rows.",
  "changes": [
    {
      "id": "jsonrpc_compliance",
      "description": "Enforce `jsonrpc == \"2.0\"` in parse_line and reject otherwise.",
      "edits": [
        {
          "file": "mcp/transport.py",
          "pattern": "def parse_line",
          "multiple": false,
          "replacement": "def parse_line(line: str):\n    import json\n    try:\n        obj = json.loads(line)\n    except Exception:\n        return {\"ok\": False, \"reason\": \"malformed_json\"}\n    if obj.get(\"jsonrpc\") != \"2.0\":\n        return {\"ok\": False, \"reason\": \"invalid_jsonrpc_version\"}\n    return obj"
        }
      ]
    },
    {
      "id": "test_jsonrpc_version",
      "description": "Add unit test rejecting non-2.0 JSON-RPC frames.",
      "edits": [
        {
          "file": "tests/test_stdio.py",
          "pattern": ".*",
          "multiple": true,
          "replacement": "import pytest, io\nfrom mcp import transport\n\n\ndef test_parse_line_rejects_wrong_jsonrpc():\n    bad = '{\"jsonrpc\": \"1.0\", \"method\": \"validate\", \"id\": 1}'\n    res = transport.parse_line(bad)\n    assert res[\"ok\"] is False\n    assert res[\"reason\"] == \"invalid_jsonrpc_version\""
        }
      ]
    },
    {
      "id": "stdio_sigterm_test",
      "description": "Extend entrypoint test to cover SIGTERM cleanup and ready-file removal.",
      "edits": [
        {
          "file": "tests/test_entrypoint.py",
          "pattern": "def test_entrypoint_ready_and_shutdown",
          "multiple": false,
          "replacement": "def test_entrypoint_ready_and_shutdown(tmp_path):\n    import subprocess, signal, os\n    proc = subprocess.Popen([\"python\", \"-m\", \"mcp.stdio_main\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n    try:\n        while True:\n            line = proc.stderr.readline()\n            if \"mcp:ready stdio\" in line:\n                break\n        ready_file = tmp_path / \"ready\"\n        proc.send_signal(signal.SIGTERM)\n        proc.wait(timeout=5)\n        assert proc.returncode == -signal.SIGTERM\n        # assert ready file cleaned up\n        if ready_file.exists():\n            raise AssertionError(\"ready file not removed on SIGTERM\")\n    finally:\n        try: proc.terminate()\n        except Exception: pass"
        }
      ]
    },
    {
      "id": "socket_tcp_sigterm_tests",
      "description": "Add SIGTERM-driven shutdown tests for socket and TCP transports.",
      "edits": [
        {
          "file": "tests/test_socket.py",
          "pattern": ".*",
          "multiple": true,
          "replacement": "import subprocess, signal, os, pytest\n\n\ndef test_socket_sigterm_shutdown(tmp_path):\n    sock_path = tmp_path / \"mcp.sock\"\n    env = os.environ.copy()\n    env[\"MCP_SOCKET_PATH\"] = str(sock_path)\n    proc = subprocess.Popen([\"python\", \"-m\", \"mcp.socket_main\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, env=env)\n    try:\n        while True:\n            line = proc.stderr.readline()\n            if \"mcp:ready socket\" in line:\n                break\n        proc.send_signal(signal.SIGTERM)\n        proc.wait(timeout=5)\n        assert proc.returncode == -signal.SIGTERM\n    finally:\n        try: proc.terminate()\n        except Exception: pass"
        },
        {
          "file": "tests/test_tcp.py",
          "pattern": ".*",
          "multiple": true,
          "replacement": "import subprocess, signal, pytest\n\n\ndef test_tcp_sigterm_shutdown():\n    proc = subprocess.Popen([\"python\", \"-m\", \"mcp.tcp_main\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n    try:\n        while True:\n            line = proc.stderr.readline()\n            if \"mcp:ready tcp\" in line:\n                break\n        proc.send_signal(signal.SIGTERM)\n        proc.wait(timeout=5)\n        assert proc.returncode == -signal.SIGTERM\n    finally:\n        try: proc.terminate()\n        except Exception: pass"
        }
      ]
    }
  ],
  "constraints": {
    "rules": [
      "No new dependencies.",
      "Edits confined to listed files.",
      "Tests must be deterministic and CI-safe.",
      "Ensure backward compatibility for valid JSON-RPC 2.0 frames."
    ]
  },
  "exit_criteria": [
    "parse_line rejects frames with jsonrpc != '2.0' and unit test passes.",
    "STDIO SIGTERM test asserts exit code and ready file cleanup.",
    "Socket and TCP SIGTERM tests assert exit code -SIGTERM and cleanup.",
    "All tests green, no regressions.",
    "Audit rerun shows zero Missing/Divergent rows."
  ]
}
